<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎯 分布式多个体数据源设计思路</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .main-content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            padding: 40px;
            margin: 20px 0;
        }

        h1 {
            color: #4a90e2;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h2 {
            color: #2c3e50;
            border-left: 4px solid #4a90e2;
            padding-left: 15px;
            margin: 30px 0 20px 0;
            font-size: 1.8em;
        }

        h3 {
            color: #34495e;
            margin: 25px 0 15px 0;
            font-size: 1.4em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
        }

        h4 {
            color: #e74c3c;
            margin: 20px 0 10px 0;
            font-size: 1.2em;
        }

        .status-analysis {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .status-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #007bff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .status-card h4 {
            color: #007bff;
            margin-bottom: 15px;
        }

        .architecture-flow {
            background: #e8f5e8;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #28a745;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.8;
        }

        .best-practices {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .practice-card {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            border-radius: 10px;
            padding: 20px;
            color: white;
            box-shadow: 0 4px 15px rgba(255, 154, 158, 0.3);
        }

        .practice-card h4 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .design-solutions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .solution-card {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            border-radius: 15px;
            padding: 25px;
            color: white;
            box-shadow: 0 8px 25px rgba(132, 250, 176, 0.3);
            transform: translateY(0);
            transition: transform 0.3s ease;
        }

        .solution-card:hover {
            transform: translateY(-5px);
        }

        .solution-card h4 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .tech-points {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .tech-card {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(255, 234, 167, 0.3);
        }

        .roadmap {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            border-radius: 15px;
            padding: 30px;
            margin: 20px 0;
            color: #2c3e50;
        }

        .roadmap-phase {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            border-left: 5px solid #6c5ce7;
        }

        .roadmap-phase h4 {
            color: #6c5ce7;
            margin-bottom: 10px;
        }

        .architecture-recommendation {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            text-align: center;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .architecture-recommendation h3 {
            color: #fff;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            margin-bottom: 20px;
        }

        pre {
            background: #2d3748;
            color: #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            overflow-x: auto;
            margin: 10px 0;
            font-size: 13px;
            line-height: 1.5;
        }

        code {
            background: #f1f3f4;
            padding: 2px 6px;
            border-radius: 4px;
            color: #c7254e;
            font-family: 'Courier New', monospace;
        }

        .highlight {
            background: linear-gradient(90deg, rgba(255, 193, 7, 0.2), rgba(255, 193, 7, 0.1));
            padding: 2px 6px;
            border-radius: 4px;
            border-left: 3px solid #ffc107;
        }

        .emoji {
            font-size: 1.2em;
            margin-right: 8px;
        }

        ul, ol {
            margin: 15px 0;
            padding-left: 25px;
        }

        li {
            margin: 8px 0;
        }

        .footer {
            text-align: center;
            padding: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .main-content {
                padding: 20px;
            }

            .status-analysis,
            .best-practices,
            .design-solutions,
            .tech-points {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 2em;
            }

            h2 {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <h1><span class="emoji">🎯</span>分布式多个体数据源设计思路</h1>

            <h2><span class="emoji">📊</span>现状分析</h2>
            
            <div class="status-analysis">
                <div class="status-card">
                    <h4><span class="emoji">🔄</span>当前架构 (单体模拟器)</h4>
                    <div class="architecture-flow">
turn_fault_simulator.py
    ↓ WebSocket
后端 main.py (WebSocket处理)
    ↓ Simple/Redis Queue
实时诊断分析
                    </div>
                </div>

                <div class="status-card">
                    <h4><span class="emoji">🎯</span>目标架构 (分布式多个体)</h4>
                    <div class="architecture-flow">
多个车辆模拟器 (Vehicle_001, Vehicle_002, ...)
    ↓ HTTP REST API
后端 diagnosis-stream API
    ↓ Redis Stream
分布式消费者组处理
                    </div>
                </div>
            </div>

            <h2><span class="emoji">🏗️</span>业界最佳实践</h2>

            <div class="best-practices">
                <div class="practice-card">
                    <h4><span class="emoji">1️⃣</span>IoT设备模拟器模式 (推荐)</h4>
                    <pre><code class="python"># 每个车辆 = 独立的模拟器进程
class VehicleSimulator:
    def __init__(self, vehicle_id, api_endpoint):
        self.vehicle_id = vehicle_id
        self.api_endpoint = api_endpoint
    
    async def start_simulation(self):
        while True:
            sensor_data = self.generate_sensor_data()
            await self.send_to_api(sensor_data)
            await asyncio.sleep(self.interval)</code></pre>
                </div>

                <div class="practice-card">
                    <h4><span class="emoji">2️⃣</span>微服务架构模式</h4>
                    <ul>
                        <li><strong>数据生成服务</strong> - 负责传感器数据模拟</li>
                        <li><strong>数据发送服务</strong> - 负责API调用和重试机制</li>
                        <li><strong>协调服务</strong> - 管理多个车辆的启动停止</li>
                    </ul>
                </div>

                <div class="practice-card">
                    <h4><span class="emoji">3️⃣</span>云原生模式</h4>
                    <ul>
                        <li>每个车辆作为独立容器</li>
                        <li>支持动态扩缩容</li>
                        <li>配置和状态外部化</li>
                    </ul>
                </div>
            </div>

            <h2><span class="emoji">🎨</span>具体设计方案</h2>

            <div class="design-solutions">
                <div class="solution-card">
                    <h4><span class="emoji">📦</span>方案1: 单进程多车辆 (简单开始)</h4>
                    <pre><code class="python">class MultiVehicleSimulator:
    def __init__(self, vehicle_count=10):
        self.vehicles = [
            VehicleAgent(f"V{i:03d}") 
            for i in range(1, vehicle_count+1)
        ]
    
    async def start_all(self):
        tasks = [vehicle.simulate() for vehicle in self.vehicles]
        await asyncio.gather(*tasks)</code></pre>
                </div>

                <div class="solution-card">
                    <h4><span class="emoji">⚡</span>方案2: 多进程协调 (生产级)</h4>
                    <pre><code class="python">class DistributedVehicleFleet:
    def __init__(self, fleet_config):
        self.fleet_config = fleet_config
        self.processes = []
    
    def spawn_vehicle(self, vehicle_config):
        process = Process(target=run_vehicle, args=(vehicle_config,))
        self.processes.append(process)
        process.start()</code></pre>
                </div>

                <div class="solution-card">
                    <h4><span class="emoji">🔧</span>方案3: 基于配置驱动 (最灵活)</h4>
                    <pre><code class="yaml"># fleet_config.yaml
vehicles:
  - id: "BJ_001"
    location: "北京"
    fault_profile: "normal"
    send_interval: 2.0
  - id: "SH_002" 
    location: "上海"
    fault_profile: "bearing_fault"
    send_interval: 1.5</code></pre>
                </div>
            </div>

            <h2><span class="emoji">🔧</span>技术实现关键点</h2>

            <div class="tech-points">
                <div class="tech-card">
                    <h4><span class="emoji">1️⃣</span>数据发送策略</h4>
                    <pre><code class="python"># 异步批量发送
async def batch_send_data(vehicles_data):
    tasks = []
    for vehicle_id, data in vehicles_data.items():
        task = send_vehicle_data(vehicle_id, data)
        tasks.append(task)
    
    results = await asyncio.gather(*tasks, return_exceptions=True)
    return results</code></pre>
                </div>

                <div class="tech-card">
                    <h4><span class="emoji">2️⃣</span>故障注入和场景模拟</h4>
                    <pre><code class="python"># 动态故障注入
class FaultScenarioManager:
    def __init__(self):
        self.scenarios = {
            "normal_operations": {"fault_rate": 0.05},
            "maintenance_day": {"fault_rate": 0.3},
            "extreme_weather": {"fault_rate": 0.8}
        }
    
    def apply_scenario(self, scenario_name):
        # 动态调整车辆故障参数
        pass</code></pre>
                </div>

                <div class="tech-card">
                    <h4><span class="emoji">3️⃣</span>负载均衡和限流</h4>
                    <pre><code class="python"># 智能发送间隔
class AdaptiveRateLimiter:
    def __init__(self, max_qps=100):
        self.max_qps = max_qps
        self.current_load = 0
    
    async def throttle(self):
        if self.current_load > self.max_qps:
            await asyncio.sleep(1.0 / self.max_qps)</code></pre>
                </div>
            </div>

            <h2><span class="emoji">📋</span>推荐实施路线图</h2>

            <div class="roadmap">
                <div class="roadmap-phase">
                    <h4><span class="emoji">🚀</span>阶段1: 快速原型 (1-2天)</h4>
                    <ol>
                        <li>创建 <code>MultiVehicleSimulator</code> 类</li>
                        <li>复用现有的数据生成逻辑</li>
                        <li>集成Redis Stream API调用</li>
                        <li>支持3-5个车辆并发</li>
                    </ol>
                </div>

                <div class="roadmap-phase">
                    <h4><span class="emoji">⭐</span>阶段2: 增强功能 (3-5天)</h4>
                    <ol>
                        <li>添加车辆配置文件支持</li>
                        <li>实现故障场景管理</li>
                        <li>添加性能监控和指标</li>
                        <li>支持10-20个车辆</li>
                    </ol>
                </div>

                <div class="roadmap-phase">
                    <h4><span class="emoji">🏆</span>阶段3: 生产优化 (1周)</h4>
                    <ol>
                        <li>多进程架构</li>
                        <li>容错和重试机制</li>
                        <li>动态扩缩容</li>
                        <li>支持100+车辆</li>
                    </ol>
                </div>
            </div>

            <div class="architecture-recommendation">
                <h3><span class="emoji">🎯</span>推荐架构升级路径</h3>
                <p class="highlight">基于现有代码基础，采用<strong>渐进式架构升级</strong>：</p>
                
                <div class="architecture-flow" style="background: rgba(255, 255, 255, 0.1); color: white; margin: 20px 0;">
第一步: 适配器模式
turn_fault_simulator.py → RedisStreamAdapter → diagnosis-stream API

第二步: 多车辆模式  
MultiVehicleSimulator[车辆1..N] → Redis Stream API

第三步: 分布式模式
独立车辆进程[fleet] → 协调器 → Redis Stream
                </div>

                <p><strong>优势:</strong> 保持现有代码复用性，逐步演进到分布式架构</p>
                <p><strong>建议:</strong> 从<span class="highlight">阶段1的适配器模式</span>开始，快速验证Redis Stream API集成效果</p>
            </div>

        </div>

        <div class="footer">
            <p>🚀 Redis Stream 分布式诊断系统 - 车联网多个体数据源架构设计 🚀</p>
            <p>© 2025 电机故障诊断系统 - 性能优化与分布式升级方案</p>
        </div>
    </div>
</body>
</html> 