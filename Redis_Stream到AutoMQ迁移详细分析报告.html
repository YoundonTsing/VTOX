<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redis Stream → AutoMQ 迁移详细分析报告</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 30px rgba(0,0,0,0.1);
            min-height: 100vh;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 40px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grain" width="100" height="100" patternUnits="userSpaceOnUse"><circle cx="25" cy="25" r="1" fill="rgba(255,255,255,0.1)"/><circle cx="75" cy="75" r="1" fill="rgba(255,255,255,0.1)"/><circle cx="50" cy="10" r="0.5" fill="rgba(255,255,255,0.05)"/></pattern></defs><rect width="100" height="100" fill="url(%23grain)"/></svg>');
            opacity: 0.3;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
        }
        
        .header .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }
        
        .content {
            padding: 40px;
        }
        
        .section {
            margin-bottom: 40px;
        }
        
        .section h2 {
            color: #2c3e50;
            font-size: 1.8rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3498db;
            position: relative;
        }
        
        .section h2::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 50px;
            height: 3px;
            background: #e74c3c;
        }
        
        .section h3 {
            color: #34495e;
            font-size: 1.4rem;
            margin: 25px 0 15px 0;
        }
        
        .section h4 {
            color: #2980b9;
            font-size: 1.2rem;
            margin: 20px 0 10px 0;
        }
        
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 20px 0;
        }
        
        .keep-unchanged, .major-changes {
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .keep-unchanged {
            background: linear-gradient(135deg, #d5f4e6 0%, #c8e6c9 100%);
            border-left: 5px solid #27ae60;
        }
        
        .major-changes {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            border-left: 5px solid #e74c3c;
        }
        
        .keep-unchanged h3 {
            color: #27ae60;
            margin-bottom: 15px;
        }
        
        .major-changes h3 {
            color: #e74c3c;
            margin-bottom: 15px;
        }
        
        .code-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            overflow-x: auto;
            position: relative;
            font-size: 0.9rem;
        }
        
        .code-block.redis {
            border-top: 4px solid #dc382d;
        }
        
        .code-block.automq {
            border-top: 4px solid #2ecc71;
        }
        
        .code-block::before {
            position: absolute;
            top: 5px;
            right: 10px;
            font-size: 0.8rem;
            opacity: 0.6;
            font-weight: bold;
        }
        
        .code-block.redis::before {
            content: 'Redis Stream';
            color: #dc382d;
        }
        
        .code-block.automq::before {
            content: 'AutoMQ';
            color: #2ecc71;
        }
        
        .migration-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .migration-table th {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            padding: 15px 12px;
            text-align: left;
            font-weight: 600;
        }
        
        .migration-table td {
            padding: 12px;
            border-bottom: 1px solid #ecf0f1;
            vertical-align: top;
        }
        
        .migration-table tbody tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        .migration-table tbody tr:hover {
            background-color: #e3f2fd;
        }
        
        .effort-low {
            background: #d5f4e6;
            color: #27ae60;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        .effort-medium {
            background: #fff3cd;
            color: #856404;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        .effort-high {
            background: #ffebee;
            color: #c62828;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.9rem;
        }
        
        .timeline-container {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 30px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .timeline-item {
            display: flex;
            align-items: flex-start;
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
        }
        
        .timeline-week {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            min-width: 80px;
            height: 40px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 20px;
            flex-shrink: 0;
        }
        
        .timeline-content {
            flex: 1;
        }
        
        .timeline-content h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .timeline-content .tasks {
            list-style: none;
            padding: 0;
        }
        
        .timeline-content .tasks li {
            padding: 5px 0;
            padding-left: 20px;
            position: relative;
        }
        
        .timeline-content .tasks li::before {
            content: '▸';
            position: absolute;
            left: 0;
            color: #3498db;
            font-weight: bold;
        }
        
        .architecture-diagram {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 10px;
        }
        
        .highlight-box {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border: 1px solid #ffc107;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .highlight-box h4 {
            color: #856404;
            margin-bottom: 10px;
        }
        
        .warning-box {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            border: 2px solid #f44336;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .warning-box h4 {
            color: #c62828;
            margin-bottom: 10px;
        }
        
        .success-box {
            background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%);
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .success-box h4 {
            color: #2e7d32;
            margin-bottom: 10px;
        }
        
        .component-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .component-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: transform 0.2s ease;
        }
        
        .component-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
        }
        
        .component-card h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        
        .footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 30px;
            margin-top: 40px;
        }
        
        @media (max-width: 768px) {
            .comparison-grid, .code-comparison {
                grid-template-columns: 1fr;
            }
            
            .content {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Redis Stream → AutoMQ 迁移详细分析</h1>
            <p class="subtitle">车联网故障诊断系统架构升级实施方案</p>
        </header>

        <main class="content">
            <!-- 迁移概览 -->
            <section class="section">
                <h2>🎯 迁移概览</h2>
                
                <div class="highlight-box">
                    <h4>📊 迁移复杂度评估</h4>
                    <ul>
                        <li><strong>总体复杂度：</strong>中等（60%代码保持不变，40%需要适配）</li>
                        <li><strong>预计工期：</strong>6-8周</li>
                        <li><strong>风险等级：</strong>中低风险（AutoMQ兼容Kafka API）</li>
                        <li><strong>业务中断时间：</strong>预计2-4小时（切换期间）</li>
                    </ul>
                </div>
                
                <div class="comparison-grid">
                    <div class="keep-unchanged">
                        <h3>✅ 保持不变的部分 (60%)</h3>
                        <ul>
                            <li><strong>业务逻辑层：</strong>故障分析算法完全不变</li>
                            <li><strong>数据模型：</strong>DiagnosisResult、FaultType等保持原样</li>
                            <li><strong>前端界面：</strong>WebSocket接口和UI无需修改</li>
                            <li><strong>配置管理：</strong>大部分配置参数保持兼容</li>
                            <li><strong>监控系统：</strong>性能指标采集逻辑不变</li>
                            <li><strong>API接口：</strong>REST API保持向后兼容</li>
                        </ul>
                    </div>
                    
                    <div class="major-changes">
                        <h3>🔄 需要大改的部分 (40%)</h3>
                        <ul>
                            <li><strong>消息队列客户端：</strong>从Redis客户端改为Kafka客户端</li>
                            <li><strong>连接管理：</strong>连接字符串和认证方式变更</li>
                            <li><strong>消息发布：</strong>XADD → Kafka Producer</li>
                            <li><strong>消息消费：</strong>XREADGROUP → Kafka Consumer</li>
                            <li><strong>分区策略：</strong>从Stream改为Topic+Partition</li>
                            <li><strong>消费者组管理：</strong>适配Kafka Consumer Group</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- 详细组件分析 -->
            <section class="section">
                <h2>🔍 详细组件迁移分析</h2>
                
                <table class="migration-table">
                    <thead>
                        <tr>
                            <th>组件/文件</th>
                            <th>当前实现</th>
                            <th>迁移复杂度</th>
                            <th>主要变更</th>
                            <th>保持不变</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>DistributedDiagnosisStream</strong></td>
                            <td>Redis Stream核心</td>
                            <td><span class="effort-high">高</span></td>
                            <td>
                                • 客户端从redis-py改为kafka-python<br>
                                • 连接管理完全重写<br>
                                • 消息发布/消费接口改写
                            </td>
                            <td>
                                • 故障分析器实例<br>
                                • 业务逻辑和算法<br>
                                • 数据结构定义
                            </td>
                        </tr>
                        <tr>
                            <td><strong>StreamManager</strong></td>
                            <td>Redis Stream管理器</td>
                            <td><span class="effort-medium">中</span></td>
                            <td>
                                • 初始化方法适配AutoMQ<br>
                                • 连接字符串格式变更<br>
                                • 健康检查机制调整
                            </td>
                            <td>
                                • 公共API接口<br>
                                • 错误处理逻辑<br>
                                • 统计信息收集
                            </td>
                        </tr>
                        <tr>
                            <td><strong>StreamCacheOptimizer</strong></td>
                            <td>Redis缓存优化器</td>
                            <td><span class="effort-high">高</span></td>
                            <td>
                                • 消息读取从XREADGROUP改为poll()<br>
                                • 批处理机制重构<br>
                                • 缓存策略调整
                            </td>
                            <td>
                                • 智能降采样算法<br>
                                • 性能统计逻辑<br>
                                • 前端推送机制
                            </td>
                        </tr>
                        <tr>
                            <td><strong>StreamToFrontendBridge</strong></td>
                            <td>前端桥接组件</td>
                            <td><span class="effort-medium">中</span></td>
                            <td>
                                • 消费者实现重写<br>
                                • 消息确认机制变更<br>
                                • 错误处理适配
                            </td>
                            <td>
                                • WebSocket推送逻辑<br>
                                • 数据格式转换<br>
                                • 前端API接口
                            </td>
                        </tr>
                        <tr>
                            <td><strong>StreamMaintenanceManager</strong></td>
                            <td>Redis Stream维护</td>
                            <td><span class="effort-low">低</span></td>
                            <td>
                                • 改为Kafka Topic清理<br>
                                • 使用Kafka Admin API<br>
                                • 清理策略调整
                            </td>
                            <td>
                                • 定时任务框架<br>
                                • 配置管理<br>
                                • 统计信息格式
                            </td>
                        </tr>
                        <tr>
                            <td><strong>AdaptiveConsumerManager</strong></td>
                            <td>自适应消费者管理</td>
                            <td><span class="effort-medium">中</span></td>
                            <td>
                                • 消费者扩展API适配<br>
                                • 负载监控指标调整<br>
                                • 分区重平衡处理
                            </td>
                            <td>
                                • 智能决策引擎<br>
                                • 监控和告警逻辑<br>
                                • 配置管理框架
                            </td>
                        </tr>
                        <tr>
                            <td><strong>业务分析器</strong></td>
                            <td>故障诊断算法</td>
                            <td><span class="effort-low">低</span></td>
                            <td>
                                • 无需修改
                            </td>
                            <td>
                                • TurnFaultAnalyzer<br>
                                • BearingAnalyzer<br>
                                • 所有分析算法
                            </td>
                        </tr>
                        <tr>
                            <td><strong>前端组件</strong></td>
                            <td>Vue.js + WebSocket</td>
                            <td><span class="effort-low">低</span></td>
                            <td>
                                • 无需修改
                            </td>
                            <td>
                                • 所有前端界面<br>
                                • WebSocket连接<br>
                                • 图表和可视化
                            </td>
                        </tr>
                        <tr>
                            <td><strong>REST API</strong></td>
                            <td>FastAPI路由</td>
                            <td><span class="effort-low">低</span></td>
                            <td>
                                • 配置参数调整<br>
                                • 健康检查更新
                            </td>
                            <td>
                                • API接口定义<br>
                                • 请求响应格式<br>
                                • 认证和权限
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- 核心代码对比 -->
            <section class="section">
                <h2>💻 核心代码迁移对比</h2>
                
                <h3>1. 连接和初始化</h3>
                <div class="code-comparison">
                    <div class="code-block redis">
# Redis Stream 当前实现
import redis.asyncio as redis

class DistributedDiagnosisStream:
    def __init__(self, redis_url="redis://localhost:6379"):
        self.redis_url = redis_url
        self.redis_client = None
        
    async def connect(self):
        self.redis_client = redis.from_url(
            self.redis_url,
            decode_responses=True,
            retry_on_timeout=True,
            health_check_interval=30
        )
        await self.redis_client.ping()
        await self._initialize_streams()
        
    async def _initialize_streams(self):
        # 创建消费者组
        for fault_type, group_name in self.consumer_groups.items():
            await self.redis_client.xgroup_create(
                self.streams["raw_data"], 
                group_name, 
                id="0", 
                mkstream=True
            )
                    </div>
                    
                    <div class="code-block automq">
# AutoMQ 迁移后实现
from kafka import KafkaProducer, KafkaConsumer, KafkaAdminClient
from kafka.admin import ConfigResource, ConfigResourceType

class DistributedDiagnosisStream:
    def __init__(self, bootstrap_servers="localhost:9092"):
        self.bootstrap_servers = bootstrap_servers
        self.producer = None
        self.admin_client = None
        
    async def connect(self):
        self.producer = KafkaProducer(
            bootstrap_servers=self.bootstrap_servers,
            value_serializer=lambda x: json.dumps(x).encode('utf-8'),
            key_serializer=lambda x: x.encode('utf-8'),
            acks='all',  # 确保数据安全
            retries=3
        )
        self.admin_client = KafkaAdminClient(
            bootstrap_servers=self.bootstrap_servers
        )
        await self._initialize_topics()
        
    async def _initialize_topics(self):
        # 创建Topics
        from kafka.admin import NewTopic
        topics = [
            NewTopic(name=topic, num_partitions=3, replication_factor=1)
            for topic in self.topics.values()
        ]
        self.admin_client.create_topics(topics, validate_only=False)
                    </div>
                </div>
                
                <h3>2. 消息发布</h3>
                <div class="code-comparison">
                    <div class="code-block redis">
# Redis Stream 消息发布
async def publish_motor_data(self, vehicle_id: str, 
                           sensor_data: Dict[str, Any], 
                           metadata: Dict[str, Any] = None) -> bool:
    try:
        message = {
            "vehicle_id": vehicle_id,
            "timestamp": datetime.now().isoformat(),
            "sensor_data": json.dumps(sensor_data),
            "metadata": json.dumps(metadata or {}),
            "data_type": "motor_sensor_data"
        }
        
        # 使用 XADD 发布到 Redis Stream
        message_id = await self.redis_client.xadd(
            self.streams["raw_data"],
            message,
            maxlen=50000
        )
        
        logger.debug(f"📤 发布电机数据: {message_id}")
        return True
        
    except Exception as e:
        logger.error(f"❌ 发布失败: {e}")
        return False
                    </div>
                    
                    <div class="code-block automq">
# AutoMQ 消息发布
async def publish_motor_data(self, vehicle_id: str, 
                           sensor_data: Dict[str, Any], 
                           metadata: Dict[str, Any] = None) -> bool:
    try:
        message = {
            "vehicle_id": vehicle_id,
            "timestamp": datetime.now().isoformat(),
            "sensor_data": sensor_data,  # 直接传递，无需JSON序列化
            "metadata": metadata or {},
            "data_type": "motor_sensor_data"
        }
        
        # 使用 Kafka Producer 发布
        future = self.producer.send(
            self.topics["raw_data"],
            key=vehicle_id,  # 使用vehicle_id作为分区键
            value=message,
            headers=[('source', b'vehicle_sensor')]
        )
        
        # 异步获取结果
        record_metadata = future.get(timeout=10)
        logger.debug(f"📤 发布电机数据: {record_metadata}")
        return True
        
    except Exception as e:
        logger.error(f"❌ 发布失败: {e}")
        return False
                    </div>
                </div>
                
                <h3>3. 消息消费</h3>
                <div class="code-comparison">
                    <div class="code-block redis">
# Redis Stream 消息消费
async def start_fault_diagnosis_consumer(self, fault_type: FaultType, 
                                       consumer_id: str) -> None:
    group_name = self.consumer_groups[fault_type.value]
    
    while self.is_running:
        try:
            # 使用 XREADGROUP 读取消息
            messages = await self.redis_client.xreadgroup(
                group_name,
                consumer_id,
                {self.streams["raw_data"]: ">"},
                count=10,
                block=1000
            )
            
            for stream, msgs in messages:
                for message_id, fields in msgs:
                    # 处理消息
                    result = await self._process_message(fields, fault_type)
                    
                    if result:
                        # 发布结果
                        await self.redis_client.xadd(
                            self.streams["fault_results"],
                            result
                        )
                    
                    # 确认消息
                    await self.redis_client.xack(
                        stream, group_name, message_id
                    )
                    
        except Exception as e:
            logger.error(f"❌ 消费失败: {e}")
                    </div>
                    
                    <div class="code-block automq">
# AutoMQ 消息消费
async def start_fault_diagnosis_consumer(self, fault_type: FaultType, 
                                       consumer_id: str) -> None:
    group_name = self.consumer_groups[fault_type.value]
    
    consumer = KafkaConsumer(
        self.topics["raw_data"],
        bootstrap_servers=self.bootstrap_servers,
        group_id=group_name,
        client_id=consumer_id,
        value_deserializer=lambda x: json.loads(x.decode('utf-8')),
        key_deserializer=lambda x: x.decode('utf-8'),
        enable_auto_commit=False,  # 手动提交
        max_poll_records=10
    )
    
    while self.is_running:
        try:
            # 使用 poll 读取消息
            message_batch = consumer.poll(timeout_ms=1000)
            
            for topic_partition, messages in message_batch.items():
                for message in messages:
                    # 处理消息
                    result = await self._process_message(
                        message.value, fault_type
                    )
                    
                    if result:
                        # 发布结果
                        self.producer.send(
                            self.topics["fault_results"],
                            key=message.key,
                            value=result
                        )
                    
                    # 手动提交offset
                    consumer.commit_async()
                    
        except Exception as e:
            logger.error(f"❌ 消费失败: {e}")
                    </div>
                </div>
                
                <h3>4. 缓存优化器适配</h3>
                <div class="code-comparison">
                    <div class="code-block redis">
# Redis Stream 缓存优化
async def _optimized_message_receiver(self):
    consumer_id = "cache_optimizer_receiver"
    
    while self.is_running:
        try:
            # 大批量读取消息
            messages = await self.redis_client.xreadgroup(
                "optimized_fault_group",
                consumer_id,
                {
                    "fault_diagnosis_results": ">",
                    "vehicle_health_assessments": ">"
                },
                count=50,
                block=500
            )
            
            for stream, msgs in messages:
                for message_id, fields in msgs:
                    # 智能过滤和采样
                    if await self._should_process_message(fields):
                        await self.processing_queue.put(
                            (stream, message_id, fields)
                        )
                    
                    # 确认消息处理
                    await self.redis_client.xack(
                        stream, "optimized_fault_group", message_id
                    )
                    
        except Exception as e:
            logger.error(f"❌ 优化接收失败: {e}")
                    </div>
                    
                    <div class="code-block automq">
# AutoMQ 缓存优化
async def _optimized_message_receiver(self):
    consumer = KafkaConsumer(
        self.topics["fault_results"],
        self.topics["health_assessments"],
        bootstrap_servers=self.bootstrap_servers,
        group_id="optimized_fault_group",
        client_id="cache_optimizer_receiver",
        value_deserializer=lambda x: json.loads(x.decode('utf-8')),
        enable_auto_commit=False,
        max_poll_records=50,  # 批量处理
        fetch_min_bytes=1024,  # 最小批次大小
        fetch_max_wait_ms=500  # 最大等待时间
    )
    
    while self.is_running:
        try:
            # 批量拉取消息
            message_batch = consumer.poll(timeout_ms=500)
            
            for topic_partition, messages in message_batch.items():
                for message in messages:
                    # 智能过滤和采样
                    if await self._should_process_message(message.value):
                        await self.processing_queue.put(
                            (message.topic, message.offset, message.value)
                        )
                
                # 批量提交offset
                consumer.commit_async()
                    
        except Exception as e:
            logger.error(f"❌ 优化接收失败: {e}")
                    </div>
                </div>
            </section>

            <!-- 配置文件变更 -->
            <section class="section">
                <h2>⚙️ 配置文件变更对比</h2>
                
                <div class="code-comparison">
                    <div class="code-block redis">
# 当前 Redis Stream 配置
# backend/app/core/config.py
REDIS_URL = "redis://localhost:6379"
REDIS_DECODE_RESPONSES = True
REDIS_RETRY_ON_TIMEOUT = True
REDIS_HEALTH_CHECK_INTERVAL = 30

# Stream 配置
REDIS_STREAM_MAX_LEN = 50000
REDIS_CONSUMER_BLOCK_TIME = 1000
REDIS_CONSUMER_COUNT = 10

# 维护配置
STREAM_MAINTENANCE_ENABLED = True
STREAM_MAINTENANCE_INTERVAL = 300
STREAM_DEFAULT_MAX_LENGTH = 10000
                    </div>
                    
                    <div class="code-block automq">
# AutoMQ 配置
# backend/app/core/config.py
AUTOMQ_BOOTSTRAP_SERVERS = "localhost:9092"
AUTOMQ_SECURITY_PROTOCOL = "SASL_SSL"
AUTOMQ_SASL_MECHANISM = "PLAIN"
AUTOMQ_SASL_USERNAME = "your_username"
AUTOMQ_SASL_PASSWORD = "your_password"

# Producer 配置
KAFKA_PRODUCER_ACKS = "all"
KAFKA_PRODUCER_RETRIES = 3
KAFKA_PRODUCER_BATCH_SIZE = 16384
KAFKA_PRODUCER_LINGER_MS = 10

# Consumer 配置
KAFKA_CONSUMER_MAX_POLL_RECORDS = 10
KAFKA_CONSUMER_FETCH_MIN_BYTES = 1024
KAFKA_CONSUMER_FETCH_MAX_WAIT_MS = 500
KAFKA_CONSUMER_SESSION_TIMEOUT_MS = 30000

# Topic 配置
KAFKA_TOPIC_PARTITIONS = 3
KAFKA_TOPIC_REPLICATION_FACTOR = 1
KAFKA_TOPIC_RETENTION_MS = 604800000  # 7天
                    </div>
                </div>
            </section>

            <!-- 迁移时间线 -->
            <section class="section">
                <h2>📅 详细迁移时间线</h2>
                
                <div class="timeline-container">
                    <div class="timeline-item">
                        <div class="timeline-week">第1周</div>
                        <div class="timeline-content">
                            <h4>🛠️ 环境准备和基础设施</h4>
                            <ul class="tasks">
                                <li>搭建AutoMQ测试集群</li>
                                <li>配置网络和安全策略</li>
                                <li>安装kafka-python依赖</li>
                                <li>创建Topic和分区策略</li>
                                <li>建立监控和日志系统</li>
                            </ul>
                            <p><strong>交付物：</strong>AutoMQ测试环境、基础监控</p>
                        </div>
                    </div>
                    
                    <div class="timeline-item">
                        <div class="timeline-week">第2周</div>
                        <div class="timeline-content">
                            <h4>🔧 核心组件重构</h4>
                            <ul class="tasks">
                                <li>重写DistributedDiagnosisStream类</li>
                                <li>适配StreamManager连接管理</li>
                                <li>实现消息发布和消费接口</li>
                                <li>开发消息适配器层</li>
                                <li>单元测试和集成测试</li>
                            </ul>
                            <p><strong>交付物：</strong>核心组件代码、基础测试用例</p>
                        </div>
                    </div>
                    
                    <div class="timeline-item">
                        <div class="timeline-week">第3周</div>
                        <div class="timeline-content">
                            <h4>⚡ 性能优化组件迁移</h4>
                            <ul class="tasks">
                                <li>重构StreamCacheOptimizer</li>
                                <li>适配智能降采样算法</li>
                                <li>实现批处理优化</li>
                                <li>调整StreamToFrontendBridge</li>
                                <li>性能基准测试</li>
                            </ul>
                            <p><strong>交付物：</strong>优化组件、性能测试报告</p>
                        </div>
                    </div>
                    
                    <div class="timeline-item">
                        <div class="timeline-week">第4周</div>
                        <div class="timeline-content">
                            <h4>🔄 管理和维护组件</h4>
                            <ul class="tasks">
                                <li>适配AdaptiveConsumerManager</li>
                                <li>重写StreamMaintenanceManager</li>
                                <li>实现Topic清理策略</li>
                                <li>更新监控指标采集</li>
                                <li>集成测试验证</li>
                            </ul>
                            <p><strong>交付物：</strong>管理组件、维护策略</p>
                        </div>
                    </div>
                    
                    <div class="timeline-item">
                        <div class="timeline-week">第5周</div>
                        <div class="timeline-content">
                            <h4>🧪 系统集成测试</h4>
                            <ul class="tasks">
                                <li>端到端功能测试</li>
                                <li>性能压力测试</li>
                                <li>故障恢复测试</li>
                                <li>数据一致性验证</li>
                                <li>用户验收测试</li>
                            </ul>
                            <p><strong>交付物：</strong>测试报告、问题修复</p>
                        </div>
                    </div>
                    
                    <div class="timeline-item">
                        <div class="timeline-week">第6周</div>
                        <div class="timeline-content">
                            <h4>🚀 生产环境部署</h4>
                            <ul class="tasks">
                                <li>生产环境AutoMQ集群部署</li>
                                <li>双写模式配置和启动</li>
                                <li>灰度流量切换</li>
                                <li>监控和告警配置</li>
                                <li>性能调优和优化</li>
                            </ul>
                            <p><strong>交付物：</strong>生产系统、切换方案</p>
                        </div>
                    </div>
                    
                    <div class="timeline-item">
                        <div class="timeline-week">第7-8周</div>
                        <div class="timeline-content">
                            <h4>✅ 完成切换和优化</h4>
                            <ul class="tasks">
                                <li>全量流量切换到AutoMQ</li>
                                <li>关闭Redis Stream双写</li>
                                <li>清理遗留代码和配置</li>
                                <li>性能调优和稳定性优化</li>
                                <li>文档更新和团队培训</li>
                            </ul>
                            <p><strong>交付物：</strong>完整系统、运维文档</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 技术架构对比 -->
            <section class="section">
                <h2>🏗️ 技术架构对比</h2>
                
                <div class="architecture-diagram">
                    <h3>当前 Redis Stream 架构</h3>
                    <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <pre style="font-family: monospace; font-size: 11px; line-height: 1.3;">
    ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
    │   车辆传感器     │    │   数据预处理     │    │  Redis Stream   │
    │   Vehicle       │───▶│   Preprocessor  │───▶│   Raw Data      │
    │   Sensors       │    │                 │    │   Stream        │
    └─────────────────┘    └─────────────────┘    └─────────────────┘
                                                           │
                                                           ▼
    ┌──────────────────────────────────────────────────────────────────────┐
    │                        Redis Stream 集群                            │
    │  ┌─────────────────────────────────────────────────────────────────┐ │
    │  │  motor_raw_data │ fault_diagnosis_results │ system_alerts    │ │
    │  │  Stream         │ Stream                  │ Stream           │ │
    │  └─────────────────────────────────────────────────────────────────┘ │
    │           │                    │                       │             │
    │  ┌─────────────────┐  ┌─────────────────┐    ┌─────────────────┐     │
    │  │ Consumer Group1 │  │ Consumer Group2 │    │ Consumer Group3 │     │
    │  │ (故障诊断)      │  │ (结果聚合)      │    │ (前端桥接)      │     │
    │  └─────────────────┘  └─────────────────┘    └─────────────────┘     │
    └──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                        ┌─────────────────┐
                        │   WebSocket     │
                        │   Frontend      │
                        │   Dashboard     │
                        └─────────────────┘
                        </pre>
                    </div>
                </div>
                
                <div class="architecture-diagram">
                    <h3>目标 AutoMQ 架构</h3>
                    <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
                        <pre style="font-family: monospace; font-size: 11px; line-height: 1.3;">
    ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
    │   车辆传感器     │    │   数据预处理     │    │  Kafka Producer │
    │   Vehicle       │───▶│   Preprocessor  │───▶│   (AutoMQ)      │
    │   Sensors       │    │                 │    │                 │
    └─────────────────┘    └─────────────────┘    └─────────────────┘
                                                           │
                                                           ▼
    ┌──────────────────────────────────────────────────────────────────────┐
    │                        AutoMQ 云原生集群                            │
    │  ┌─────────────────────────────────────────────────────────────────┐ │
    │  │  motor-raw-data    │ fault-results       │ system-alerts      │ │
    │  │  Topic (3分区)     │ Topic (3分区)       │ Topic (1分区)      │ │
    │  └─────────────────────────────────────────────────────────────────┘ │
    │           │                    │                       │             │
    │  ┌─────────────────┐  ┌─────────────────┐    ┌─────────────────┐     │
    │  │ Consumer Group1 │  │ Consumer Group2 │    │ Consumer Group3 │     │
    │  │ (故障诊断)      │  │ (结果聚合)      │    │ (前端桥接)      │     │
    │  │ 自动分区负载均衡 │  │ 批处理优化      │    │ 实时推送        │     │
    │  └─────────────────┘  └─────────────────┘    └─────────────────┘     │
    │                                                                      │
    │  ┌─────────────────────────────────────────────────────────────────┐ │
    │  │              云原生特性                                         │ │
    │  │  • 自动扩缩容    • 多云部署    • 成本优化    • 高可用          │ │
    │  └─────────────────────────────────────────────────────────────────┘ │
    └──────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                        ┌─────────────────┐
                        │   WebSocket     │
                        │   Frontend      │
                        │   Dashboard     │
                        └─────────────────┘
                        </pre>
                    </div>
                </div>
            </section>

            <!-- 关键技术细节 -->
            <section class="section">
                <h2>🔧 关键技术细节</h2>
                
                <div class="component-grid">
                    <div class="component-card">
                        <h4>🔄 消息序列化变更</h4>
                        <p><strong>Redis Stream:</strong></p>
                        <ul>
                            <li>使用Redis原生数据类型</li>
                            <li>字段值为字符串格式</li>
                            <li>JSON数据需要手动序列化</li>
                        </ul>
                        <p><strong>AutoMQ:</strong></p>
                        <ul>
                            <li>使用JSON序列化器</li>
                            <li>支持复杂数据结构</li>
                            <li>自动序列化/反序列化</li>
                        </ul>
                    </div>
                    
                    <div class="component-card">
                        <h4>📊 分区策略设计</h4>
                        <p><strong>关键原则:</strong></p>
                        <ul>
                            <li>使用vehicle_id作为分区键</li>
                            <li>确保同一车辆消息有序</li>
                            <li>3个分区支持负载均衡</li>
                            <li>故障类型独立Topic</li>
                        </ul>
                        <p><strong>分区映射:</strong></p>
                        <ul>
                            <li>motor-raw-data: 3分区</li>
                            <li>fault-results: 3分区</li>
                            <li>system-alerts: 1分区</li>
                        </ul>
                    </div>
                    
                    <div class="component-card">
                        <h4>⚡ 性能优化策略</h4>
                        <p><strong>生产者优化:</strong></p>
                        <ul>
                            <li>批处理大小: 16KB</li>
                            <li>延迟时间: 10ms</li>
                            <li>压缩算法: snappy</li>
                            <li>异步发送模式</li>
                        </ul>
                        <p><strong>消费者优化:</strong></p>
                        <ul>
                            <li>批量拉取: 50条/次</li>
                            <li>最小字节数: 1KB</li>
                            <li>最大等待: 500ms</li>
                            <li>手动提交offset</li>
                        </ul>
                    </div>
                    
                    <div class="component-card">
                        <h4>🛡️ 容错和恢复</h4>
                        <p><strong>生产者容错:</strong></p>
                        <ul>
                            <li>重试次数: 3次</li>
                            <li>acks=all 确保可靠性</li>
                            <li>幂等性保证</li>
                            <li>事务支持(可选)</li>
                        </ul>
                        <p><strong>消费者容错:</strong></p>
                        <ul>
                            <li>自动重平衡</li>
                            <li>会话超时: 30秒</li>
                            <li>心跳间隔: 3秒</li>
                            <li>失败重试机制</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- 风险评估和缓解 -->
            <section class="section">
                <h2>⚠️ 风险评估和缓解措施</h2>
                
                <div class="warning-box">
                    <h4>🚨 高风险项</h4>
                    <ul>
                        <li><strong>数据丢失风险:</strong>迁移过程中可能出现消息丢失</li>
                        <li><strong>性能下降:</strong>初期配置可能不够优化</li>
                        <li><strong>兼容性问题:</strong>消息格式和API变更</li>
                        <li><strong>运维复杂度:</strong>团队需要学习新技术栈</li>
                    </ul>
                </div>
                
                <div class="success-box">
                    <h4>✅ 缓解措施</h4>
                    <ul>
                        <li><strong>双写策略:</strong>Redis和AutoMQ同时写入，确保数据安全</li>
                        <li><strong>灰度发布:</strong>分阶段切换，及时发现和解决问题</li>
                        <li><strong>回滚预案:</strong>完整的回滚流程，5分钟内恢复</li>
                        <li><strong>全面监控:</strong>实时监控系统状态和性能指标</li>
                        <li><strong>团队培训:</strong>提前进行AutoMQ技术培训</li>
                        <li><strong>专家支持:</strong>联系AutoMQ技术支持团队</li>
                    </ul>
                </div>
            </section>

            <!-- 成本效益分析 -->
            <section class="section">
                <h2>💰 迁移成本效益分析</h2>
                
                <table class="migration-table">
                    <thead>
                        <tr>
                            <th>成本项目</th>
                            <th>一次性成本</th>
                            <th>年度成本变化</th>
                            <th>说明</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>开发成本</td>
                            <td>$60,000</td>
                            <td>-</td>
                            <td>6-8周开发工作，包括测试和部署</td>
                        </tr>
                        <tr>
                            <td>基础设施成本</td>
                            <td>$5,000</td>
                            <td>-$30,000</td>
                            <td>AutoMQ云原生架构，降低50-80%成本</td>
                        </tr>
                        <tr>
                            <td>运维成本</td>
                            <td>$10,000</td>
                            <td>-$80,000</td>
                            <td>自动化运维，减少人工干预</td>
                        </tr>
                        <tr>
                            <td>培训成本</td>
                            <td>$15,000</td>
                            <td>-</td>
                            <td>团队技能培训和知识转移</td>
                        </tr>
                        <tr>
                            <td>风险缓解</td>
                            <td>$10,000</td>
                            <td>-</td>
                            <td>双写期间额外资源消耗</td>
                        </tr>
                        <tr style="background-color: #e8f5e8; font-weight: bold;">
                            <td>总计</td>
                            <td>$100,000</td>
                            <td>-$110,000</td>
                            <td>投资回报期: 11个月</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="highlight-box">
                    <h4>📈 预期收益</h4>
                    <ul>
                        <li><strong>性能提升:</strong>吞吐量提升5-10倍，延迟降低30%</li>
                        <li><strong>扩展性:</strong>支持无限水平扩展，适应业务增长</li>
                        <li><strong>可靠性:</strong>99.99%可用性，故障恢复时间<1分钟</li>
                        <li><strong>成本优化:</strong>年度运营成本降低60-70%</li>
                        <li><strong>开发效率:</strong>Kafka生态丰富，开发效率提升40%</li>
                    </ul>
                </div>
            </section>

            <!-- 实施建议 -->
            <section class="section">
                <h2>🎯 实施建议</h2>
                
                <div class="success-box">
                    <h4>✅ 推荐实施AutoMQ迁移</h4>
                    <p><strong>理由:</strong></p>
                    <ul>
                        <li>AutoMQ提供Kafka API 100%兼容，迁移风险可控</li>
                        <li>云原生架构带来显著的成本和运维优势</li>
                        <li>性能提升明显，能够支撑未来业务增长</li>
                        <li>技术栈统一，便于团队技能发展</li>
                    </ul>
                </div>
                
                <div class="component-grid">
                    <div class="component-card">
                        <h4>🚀 立即开始</h4>
                        <ul>
                            <li>申请AutoMQ试用账号</li>
                            <li>搭建测试环境</li>
                            <li>开展团队技术培训</li>
                            <li>制定详细项目计划</li>
                        </ul>
                    </div>
                    
                    <div class="component-card">
                        <h4>📋 准备工作</h4>
                        <ul>
                            <li>梳理现有业务流程</li>
                            <li>确定迁移优先级</li>
                            <li>准备测试数据集</li>
                            <li>建立监控基线</li>
                        </ul>
                    </div>
                    
                    <div class="component-card">
                        <h4>🛡️ 风险控制</h4>
                        <ul>
                            <li>制定完整回滚预案</li>
                            <li>建立应急响应机制</li>
                            <li>准备技术支持渠道</li>
                            <li>安排专人负责监控</li>
                        </ul>
                    </div>
                    
                    <div class="component-card">
                        <h4>📈 持续优化</h4>
                        <ul>
                            <li>定期性能调优</li>
                            <li>监控成本变化</li>
                            <li>收集用户反馈</li>
                            <li>规划后续升级</li>
                        </ul>
                    </div>
                </div>
            </section>
        </main>

        <footer class="footer">
            <p>&copy; 2025 Redis Stream → AutoMQ 迁移分析报告</p>
            <p>报告生成时间：2025年1月 | 技术架构升级指导文档</p>
        </footer>
    </div>
</body>
</html> 